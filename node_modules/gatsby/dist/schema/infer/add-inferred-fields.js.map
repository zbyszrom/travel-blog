{"version":3,"sources":["../../../src/schema/infer/add-inferred-fields.js"],"names":["_","require","defaultFieldResolver","getNamedType","GraphQLObjectType","GraphQLList","invariant","report","isFile","link","fileByPath","isDate","dateResolver","is32BitInteger","addInferredFields","schemaComposer","typeComposer","exampleValue","nodeStore","inferConfig","typeMapping","parentSpan","addInferredFieldsImpl","exampleObject","prefix","getTypeName","addNewFields","infer","addDefaultResolvers","module","exports","fields","Object","keys","forEach","unsanitizedKey","push","getFieldConfig","fieldsByKey","groupBy","field","key","possibleFields","fieldConfig","length","resolveMultipleFields","possibleFieldsNames","map","join","warn","arrays","namedInferredType","type","Array","isArray","hasField","fieldType","getFieldType","lists","namedFieldType","ofType","name","fieldTypeComposer","getFieldTC","inferredFields","getFields","addFields","getField","isEmpty","args","resolve","setField","TypeComposer","add","createFieldName","selector","value","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","split","getSimpleFieldConfig","resolver","source","context","info","fieldName","nodeField","find","canonicalField","sortBy","mapping","path","by","foreignKey","replace","getNodeBy","getNodes","node","get","getNode","linkedNodes","linkedTypes","uniq","filter","Boolean","internal","typeName","sort","getOrCreateUTC","utc","types","getOrCreateTC","setTypes","setResolveType","has","Date","String","originalFieldTypeComposer","clone","createTemp","createTypeName","Error","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","replaced","match","char","index"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst {\n  defaultFieldResolver,\n  getNamedType,\n  GraphQLObjectType,\n  GraphQLList,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst { isFile } = require(`./is-file`)\nconst { link, fileByPath } = require(`../resolvers`)\nconst { isDate, dateResolver } = require(`../types/date`)\nconst is32BitInteger = require(`./is-32-bit-integer`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  nodeStore,\n  inferConfig,\n  typeMapping,\n  parentSpan,\n}) => {\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    nodeStore,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    typeMapping,\n    addNewFields: inferConfig ? inferConfig.infer : true,\n    addDefaultResolvers: inferConfig ? inferConfig.addDefaultResolvers : true,\n  })\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  exampleObject,\n  typeMapping,\n  prefix,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const exampleValue = exampleObject[unsanitizedKey]\n    fields.push(\n      getFieldConfig({\n        schemaComposer,\n        typeComposer,\n        nodeStore,\n        prefix,\n        exampleValue,\n        unsanitizedKey,\n        typeMapping,\n        addNewFields,\n        addDefaultResolvers,\n      })\n    )\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let fieldConfig\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${\n          field.key\n        }\\` - [${possibleFieldsNames}]. Gatsby will use \\`${\n          field.unsanitizedKey\n        }\\`.`\n      )\n      fieldConfig = field.fieldConfig\n    } else {\n      fieldConfig = possibleFields[0].fieldConfig\n    }\n\n    let arrays = 0\n    let namedInferredType = fieldConfig.type\n    while (Array.isArray(namedInferredType)) {\n      namedInferredType = namedInferredType[0]\n      arrays++\n    }\n\n    if (typeComposer.hasField(key)) {\n      const fieldType = typeComposer.getFieldType(key)\n\n      let lists = 0\n      let namedFieldType = fieldType\n      while (namedFieldType.ofType) {\n        namedFieldType = namedFieldType.ofType\n        if (namedFieldType instanceof GraphQLList) {\n          lists++\n        }\n      }\n\n      if (arrays === lists) {\n        if (\n          namedFieldType instanceof GraphQLObjectType &&\n          typeof namedInferredType !== `string` &&\n          namedFieldType.name === namedInferredType.getTypeName()\n        ) {\n          const fieldTypeComposer = typeComposer.getFieldTC(key)\n          const inferredFields = namedInferredType.getFields()\n          fieldTypeComposer.addFields(inferredFields)\n        } else if (\n          addDefaultResolvers &&\n          namedFieldType.name === namedInferredType\n        ) {\n          let field = typeComposer.getField(key)\n          if (!field.type) {\n            field = {\n              type: field,\n            }\n          }\n          if (_.isEmpty(field.args) && fieldConfig.args) {\n            field.args = fieldConfig.args\n          }\n          if (!field.resolve && fieldConfig.resolve) {\n            field.resolve = fieldConfig.resolve\n          }\n          typeComposer.setField(key, field)\n        }\n      }\n    } else if (addNewFields) {\n      if (namedInferredType instanceof schemaComposer.TypeComposer) {\n        schemaComposer.add(namedInferredType)\n      }\n      typeComposer.setField(key, fieldConfig)\n    }\n  })\n\n  return typeComposer\n}\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  prefix,\n  exampleValue,\n  unsanitizedKey,\n  typeMapping,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  let key = createFieldName(unsanitizedKey)\n  const selector = `${prefix}.${key}`\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (key.includes(`___NODE`)) {\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      nodeStore,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    key = key.split(`___NODE`)[0]\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      nodeStore,\n      key,\n      value,\n      selector,\n      typeMapping,\n      addNewFields,\n      addDefaultResolvers,\n    })\n  }\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey) {\n    const resolver = fieldConfig.resolve || defaultFieldResolver\n    fieldConfig = {\n      ...fieldConfig,\n      resolve: (source, args, context, info) =>\n        resolver(source, args, context, {\n          ...info,\n          fieldName: unsanitizedKey,\n        }),\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return {\n    key,\n    unsanitizedKey,\n    fieldConfig,\n  }\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return { type, resolve: link({ by: path.join(`.`) || `id` }) }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  nodeStore,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n\n  const getNodeBy = value =>\n    foreignKey\n      ? nodeStore.getNodes().find(node => _.get(node, foreignKey) === value)\n      : nodeStore.getNode(value)\n\n  const linkedNodes = Array.isArray(value)\n    ? value.map(getNodeBy)\n    : [getNodeBy(value)]\n\n  const linkedTypes = _.uniq(\n    linkedNodes.filter(Boolean).map(node => node.internal.type)\n  )\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  // FIXME: The naming of union types is a breaking change. In current master,\n  // the type name includes the key, which is (i) potentially not unique, and\n  // (ii) hinders reusing types.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      const types = linkedTypes.map(typeName =>\n        schemaComposer.getOrCreateTC(typeName)\n      )\n      utc.setTypes(types)\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return { type, resolve: link({ by: foreignKey || `id` }) }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  key,\n  value,\n  selector,\n  typeMapping,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return dateResolver\n      }\n      // FIXME: The weird thing is that we are trying to infer a File,\n      // but cannot assume that a source plugin for File nodes is actually present.\n      if (schemaComposer.has(`File`) && isFile(nodeStore, selector, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, resolve: fileByPath }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return dateResolver\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        // We only create a temporary TypeComposer on nested fields\n        // (either a clone of an existing field type, or a temporary new one),\n        // because we don't yet know if this type should end up in the schema.\n        // It might be for a possibleField that will be disregarded later,\n        // so we cannot mutate the original.\n        let fieldTypeComposer\n        if (\n          typeComposer.hasField(key) &&\n          getNamedType(typeComposer.getFieldType(key)) instanceof\n            GraphQLObjectType\n        ) {\n          const originalFieldTypeComposer = typeComposer.getFieldTC(key)\n          fieldTypeComposer = originalFieldTypeComposer.clone(\n            originalFieldTypeComposer.getTypeName()\n          )\n        } else {\n          fieldTypeComposer = schemaComposer.TypeComposer.createTemp(\n            createTypeName(selector)\n          )\n        }\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            nodeStore,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            addNewFields,\n            addDefaultResolvers,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const key = selector\n    .split(`.`)\n    .map(_.upperFirst)\n    .join(``)\n\n  return key\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const replaced = key.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n"],"file":"add-inferred-fields.js"}