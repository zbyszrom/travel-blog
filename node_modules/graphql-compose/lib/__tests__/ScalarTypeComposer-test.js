"use strict";

var _ = require("..");

var _graphql = require("../graphql");

beforeEach(() => {
  _.schemaComposer.clear();
});
describe('ScalarTypeComposer', () => {
  let scalarType;
  let stc;
  beforeEach(() => {
    scalarType = new _graphql.GraphQLScalarType({
      name: 'MyScalar',
      serialize: () => {}
    });
    stc = new _.ScalarTypeComposer(scalarType);
  });
  describe('create() [static method]', () => {
    it('should create STC by type template string', () => {
      const myTC = _.ScalarTypeComposer.create('scalar SDLScalar');

      expect(myTC).toBeInstanceOf(_.ScalarTypeComposer);
      expect(myTC.getTypeName()).toBe('SDLScalar');
    });
    it('should create STC by GraphQLScalarTypeConfig', () => {
      const myTC = _.ScalarTypeComposer.create({
        name: 'TestType',
        serialize: () => {}
      });

      expect(myTC).toBeInstanceOf(_.ScalarTypeComposer);
      expect(myTC.getTypeName()).toBe('TestType');
    });
    it('should create TC by GraphQLScalarType', () => {
      const objType = new _graphql.GraphQLScalarType({
        name: 'TestTypeObj',
        serialize: () => {}
      });

      const myTC = _.ScalarTypeComposer.create(objType);

      expect(myTC).toBeInstanceOf(_.ScalarTypeComposer);
      expect(myTC.getType()).toBe(objType);
    });
    it('should create STC from string', () => {
      const myTC = _.ScalarTypeComposer.create('MySSS');

      expect(myTC.getTypeName()).toEqual('MySSS');
    });
    it('should create type and store it in schemaComposer', () => {
      const SomeUserSTC = _.ScalarTypeComposer.create('SomeUserScalar');

      expect(_.schemaComposer.getSTC('SomeUserScalar')).toBe(SomeUserSTC);
    });
    it('createTemp() should not store type in schemaComposer', () => {
      _.ScalarTypeComposer.createTemp('SomeUserScalar');

      expect(_.schemaComposer.has('SomeUserScalar')).toBeFalsy();
    });
  });
  describe('serialize methods', () => {
    it('getSerialize()', () => {
      expect(typeof stc.getSerialize()).toBe('function');
    });
    it('setSerialize()', () => {
      const mySerializer = () => {};

      stc.setSerialize(mySerializer);
      expect(stc.getSerialize()).toBe(mySerializer);
    });
    it('getParseValue()', () => {
      expect(typeof stc.getParseValue()).toBe('function');
    });
    it('setParseValue()', () => {
      const myParseValue = () => {};

      stc.setParseValue(myParseValue);
      expect(stc.getParseValue()).toBe(myParseValue);
    });
    it('getParseLiteral()', () => {
      expect(typeof stc.getParseLiteral()).toBe('function');
    });
    it('setParseLiteral()', () => {
      const myParseLiteral = () => {};

      stc.setParseLiteral(myParseLiteral);
      expect(stc.getParseLiteral()).toBe(myParseLiteral);
    });
  });
  describe('type methods', () => {
    it('getType()', () => {
      expect(stc.getType()).toBeInstanceOf(_graphql.GraphQLScalarType);
    });
    it('getTypeName()', () => {
      expect(stc.getTypeName()).toBe('MyScalar');
    });
    it('setTypeName()', () => {
      expect(stc.getTypeName()).toBe('MyScalar');
      stc.setTypeName('OtherName');
      expect(stc.getTypeName()).toBe('OtherName');
    });
    it('getTypePlural() should return wrapped type with GraphQLList', () => {
      expect(stc.getTypePlural()).toBeInstanceOf(_graphql.GraphQLList);
      expect(stc.getTypePlural().ofType).toBe(stc.getType());
    });
    it('getTypeNonNull() should return wrapped type with GraphQLNonNull', () => {
      expect(stc.getTypeNonNull()).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(stc.getTypeNonNull().ofType).toBe(stc.getType());
    });
  });
  describe('clone()', () => {
    it('should clone type', () => {
      const stc2 = stc.clone('ClonedScalar');
      expect(stc2.getTypeName()).toEqual('ClonedScalar');
      expect(stc.getType()).not.toBe(stc2.getType());
      expect(() => {
        const wrongArgs = [];
        stc.clone(...wrongArgs);
      }).toThrowError(/You should provide newTypeName/);
    });
  });
});