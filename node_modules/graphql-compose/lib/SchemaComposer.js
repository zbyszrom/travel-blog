"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaComposer = void 0;

var _TypeStorage = require("./TypeStorage");

var _TypeMapper = require("./TypeMapper");

var _TypeComposer2 = require("./TypeComposer");

var _InputTypeComposer2 = require("./InputTypeComposer");

var _ScalarTypeComposer2 = require("./ScalarTypeComposer");

var _EnumTypeComposer2 = require("./EnumTypeComposer");

var _InterfaceTypeComposer2 = require("./InterfaceTypeComposer");

var _UnionTypeComposer2 = require("./UnionTypeComposer");

var _Resolver2 = require("./Resolver");

var _is = require("./utils/is");

var _misc = require("./utils/misc");

var _typeHelpers = require("./utils/typeHelpers");

var _graphql = require("./graphql");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const BUILT_IN_DIRECTIVES = [_graphql.GraphQLSkipDirective, _graphql.GraphQLIncludeDirective, _graphql.GraphQLDeprecatedDirective];

class SchemaComposer extends _TypeStorage.TypeStorage {
  constructor() {
    super();

    _defineProperty(this, "_schemaMustHaveTypes", []);

    _defineProperty(this, "_directives", BUILT_IN_DIRECTIVES);

    const schema = this;

    class TypeComposer extends _TypeComposer2.TypeComposer {}

    _defineProperty(TypeComposer, "schemaComposer", schema);

    this.TypeComposer = TypeComposer;

    class InputTypeComposer extends _InputTypeComposer2.InputTypeComposer {}

    _defineProperty(InputTypeComposer, "schemaComposer", schema);

    this.InputTypeComposer = InputTypeComposer;

    class Resolver extends _Resolver2.Resolver {}

    _defineProperty(Resolver, "schemaComposer", schema);

    this.Resolver = Resolver;

    class EnumTypeComposer extends _EnumTypeComposer2.EnumTypeComposer {}

    _defineProperty(EnumTypeComposer, "schemaComposer", schema);

    this.EnumTypeComposer = EnumTypeComposer;

    class InterfaceTypeComposer extends _InterfaceTypeComposer2.InterfaceTypeComposer {}

    _defineProperty(InterfaceTypeComposer, "schemaComposer", schema);

    this.InterfaceTypeComposer = InterfaceTypeComposer;

    class UnionTypeComposer extends _UnionTypeComposer2.UnionTypeComposer {}

    _defineProperty(UnionTypeComposer, "schemaComposer", schema);

    this.UnionTypeComposer = UnionTypeComposer;

    class ScalarTypeComposer extends _ScalarTypeComposer2.ScalarTypeComposer {}

    _defineProperty(ScalarTypeComposer, "schemaComposer", schema);

    this.ScalarTypeComposer = ScalarTypeComposer;
    this.typeMapper = new _TypeMapper.TypeMapper(schema); // alive proper Flow type casting in autosuggestions

    /* :: return this; */
  }

  get Query() {
    return this.rootQuery();
  }

  rootQuery() {
    return this.getOrCreateTC('Query');
  }

  get Mutation() {
    return this.rootMutation();
  }

  rootMutation() {
    return this.getOrCreateTC('Mutation');
  }

  get Subscription() {
    return this.rootSubscription();
  }

  rootSubscription() {
    return this.getOrCreateTC('Subscription');
  }

  buildSchema(extraConfig) {
    const roots = {};

    if (this.has('Query')) {
      const tc = this.getTC('Query');
      this.removeEmptyTypes(tc, new Set());
      roots.query = tc.getType();
    }

    if (this.has('Mutation')) {
      const tc = this.getTC('Mutation');
      this.removeEmptyTypes(tc, new Set());
      roots.mutation = tc.getType();
    }

    if (this.has('Subscription')) {
      const tc = this.getTC('Subscription');
      this.removeEmptyTypes(tc, new Set());
      roots.subscription = tc.getType();
    }

    if (!roots.query) {
      throw new Error('Can not build schema. Must be initialized Query type. See https://github.com/graphql/graphql-js/issues/448');
    }

    if (Object.keys(roots).length === 0) {
      throw new Error('Can not build schema. Must be initialized at least one ' + 'of the following types: Query, Mutation, Subscription.');
    }

    const types = [...this._schemaMustHaveTypes.map(t => (0, _typeHelpers.getGraphQLType)(t)), // additional types, eg. used in Interfaces
    ...(extraConfig && Array.isArray(extraConfig.types) ? [...extraConfig.types] : [])];
    const directives = [...this._directives, ...(extraConfig && Array.isArray(extraConfig.directives) ? [...extraConfig.directives] : [])];
    return new _graphql.GraphQLSchema(_objectSpread({}, roots, extraConfig, {
      types,
      directives
    }));
  }

  addSchemaMustHaveType(type) {
    this._schemaMustHaveTypes.push(type);

    return this;
  }

  removeEmptyTypes(typeComposer, passedTypes = new Set()) {
    typeComposer.getFieldNames().forEach(fieldName => {
      const fieldType = typeComposer.getFieldType(fieldName);

      if (fieldType instanceof _graphql.GraphQLObjectType) {
        const typeName = fieldType.name;

        if (!passedTypes.has(typeName)) {
          passedTypes.add(typeName);
          const tc = new this.TypeComposer(fieldType);

          if (Object.keys(tc.getFields()).length > 0) {
            this.removeEmptyTypes(tc, passedTypes);
          } else {
            // eslint-disable-next-line
            console.log(`graphql-compose: Delete field '${typeComposer.getTypeName()}.${fieldName}' ` + `with type '${tc.getTypeName()}', cause it does not have fields.`);
            typeComposer.removeField(fieldName);
          }
        }
      }
    });
  }

  getOrCreateTC(typeName, onCreate) {
    try {
      return this.getTC(typeName);
    } catch (e) {
      const tc = this.TypeComposer.create(typeName);
      this.set(typeName, tc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(tc);
      return tc;
    }
  }

  getOrCreateITC(typeName, onCreate) {
    try {
      return this.getITC(typeName);
    } catch (e) {
      const itc = this.InputTypeComposer.create(typeName);
      this.set(typeName, itc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(itc);
      return itc;
    }
  }

  getOrCreateETC(typeName, onCreate) {
    try {
      return this.getETC(typeName);
    } catch (e) {
      const etc = this.EnumTypeComposer.create(typeName);
      this.set(typeName, etc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(etc);
      return etc;
    }
  }

  getOrCreateIFTC(typeName, onCreate) {
    try {
      return this.getIFTC(typeName);
    } catch (e) {
      const iftc = this.InterfaceTypeComposer.create(typeName);
      this.set(typeName, iftc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(iftc);
      return iftc;
    }
  }

  getOrCreateUTC(typeName, onCreate) {
    try {
      return this.getUTC(typeName);
    } catch (e) {
      const iftc = this.UnionTypeComposer.create(typeName);
      this.set(typeName, iftc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(iftc);
      return iftc;
    }
  }

  getOrCreateSTC(typeName, onCreate) {
    try {
      return this.getSTC(typeName);
    } catch (e) {
      const stc = this.ScalarTypeComposer.create(typeName);
      this.set(typeName, stc);
      if (onCreate && (0, _is.isFunction)(onCreate)) onCreate(stc);
      return stc;
    }
  } // disable redundant noise in console.logs


  toString() {
    return 'SchemaComposer';
  }

  toJSON() {
    return 'SchemaComposer';
  }

  inspect() {
    return 'SchemaComposer';
  }

  clear() {
    super.clear();
    this._schemaMustHaveTypes = [];
    this._directives = BUILT_IN_DIRECTIVES;
  }

  getTC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLObjectType)) {
      return this.TypeComposer.create(this.get(typeName));
    }

    return super.getTC(typeName);
  }

  getITC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLInputObjectType)) {
      return this.InputTypeComposer.create(this.get(typeName));
    }

    return super.getITC(typeName);
  }

  getETC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLEnumType)) {
      return this.EnumTypeComposer.create(this.get(typeName));
    }

    return super.getETC(typeName);
  }

  getIFTC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLInterfaceType)) {
      return this.InterfaceTypeComposer.create(this.get(typeName));
    }

    return super.getIFTC(typeName);
  }

  getUTC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLUnionType)) {
      return this.UnionTypeComposer.create(this.get(typeName));
    }

    return super.getUTC(typeName);
  }

  getSTC(typeName) {
    if (this.hasInstance(typeName, _graphql.GraphQLScalarType)) {
      return this.ScalarTypeComposer.create(this.get(typeName));
    }

    return super.getSTC(typeName);
  }

  getAnyTC(typeName) {
    const type = this.get(typeName);

    if (type instanceof _TypeComposer2.TypeComposer || type instanceof _InputTypeComposer2.InputTypeComposer || type instanceof _ScalarTypeComposer2.ScalarTypeComposer || type instanceof _EnumTypeComposer2.EnumTypeComposer || type instanceof _InterfaceTypeComposer2.InterfaceTypeComposer || type instanceof _UnionTypeComposer2.UnionTypeComposer) {
      return type;
    } else if (type instanceof _graphql.GraphQLObjectType) {
      return this.TypeComposer.create(type);
    } else if (type instanceof _graphql.GraphQLInputObjectType) {
      return this.InputTypeComposer.create(type);
    } else if (type instanceof _graphql.GraphQLScalarType) {
      return this.ScalarTypeComposer.create(type);
    } else if (type instanceof _graphql.GraphQLEnumType) {
      return this.EnumTypeComposer.create(type);
    } else if (type instanceof _graphql.GraphQLInterfaceType) {
      return this.InterfaceTypeComposer.create(type);
    } else if (type instanceof _graphql.GraphQLUnionType) {
      return this.UnionTypeComposer.create(type);
    }

    throw new Error(`Type with name ${(0, _misc.inspect)(typeName)} cannot be obtained as any Composer helper. Put something strange?`);
  }

  add(typeOrSDL) {
    if (typeof typeOrSDL === 'string') {
      return this.addAsComposer(typeOrSDL);
    } else {
      return super.add(typeOrSDL);
    }
  }

  addAsComposer(typeOrSDL) {
    let type;

    if (typeof typeOrSDL === 'string') {
      type = this.typeMapper.createType(typeOrSDL);
    } else {
      type = typeOrSDL;
    }

    if (type instanceof _TypeComposer2.TypeComposer || type instanceof _InputTypeComposer2.InputTypeComposer || type instanceof _ScalarTypeComposer2.ScalarTypeComposer || type instanceof _EnumTypeComposer2.EnumTypeComposer || type instanceof _InterfaceTypeComposer2.InterfaceTypeComposer || type instanceof _UnionTypeComposer2.UnionTypeComposer) {
      const name = type.getTypeName();
      this.set(name, type);
      return name;
    } else if (type instanceof _graphql.GraphQLObjectType) {
      return this.TypeComposer.create(type).getTypeName();
    } else if (type instanceof _graphql.GraphQLInputObjectType) {
      return this.InputTypeComposer.create(type).getTypeName();
    } else if (type instanceof _graphql.GraphQLScalarType) {
      return this.ScalarTypeComposer.create(type).getTypeName();
    } else if (type instanceof _graphql.GraphQLEnumType) {
      return this.EnumTypeComposer.create(type).getTypeName();
    } else if (type instanceof _graphql.GraphQLInterfaceType) {
      return this.InterfaceTypeComposer.create(type).getTypeName();
    } else if (type instanceof _graphql.GraphQLUnionType) {
      return this.UnionTypeComposer.create(type).getTypeName();
    }

    throw new Error(`Cannot add as Composer type following value: ${(0, _misc.inspect)(type)}.`);
  }

  addTypeDefs(typeDefs) {
    const types = this.typeMapper.parseTypesFromString(typeDefs);
    types.forEach(type => {
      const name = type.name;

      if (name !== 'Query' && name !== 'Mutation' && name !== 'Subscription') {
        this.add(type);
      }
    });

    if (types.has('Query')) {
      this.Query.addFields(this.TypeComposer.create(types.get('Query')).getFields());
    }

    if (types.has('Mutation')) {
      this.Mutation.addFields(this.TypeComposer.create(types.get('Mutation')).getFields());
    }

    if (types.has('Subscription')) {
      this.Subscription.addFields(this.TypeComposer.create(types.get('Subscription')).getFields());
    }

    return types;
  }

  addResolveMethods(typesFieldsResolve) {
    const typeNames = Object.keys(typesFieldsResolve);
    typeNames.forEach(typeName => {
      if (this.get(typeName) instanceof _graphql.GraphQLScalarType) {
        const maybeScalar = typesFieldsResolve[typeName];

        if (maybeScalar instanceof _graphql.GraphQLScalarType) {
          this.set(typeName, maybeScalar);
          return;
        }

        if (typeof maybeScalar.name === 'string' && typeof maybeScalar.serialize === 'function') {
          this.set(typeName, new _graphql.GraphQLScalarType(maybeScalar));
          return;
        }
      }

      const tc = this.getTC(typeName);
      const fieldsResolve = typesFieldsResolve[typeName];
      const fieldNames = Object.keys(fieldsResolve);
      fieldNames.forEach(fieldName => {
        tc.extendField(fieldName, {
          resolve: fieldsResolve[fieldName]
        });
      });
    });
  } // alias for createObjectTC


  createTC(typeDef) {
    return this.createObjectTC(typeDef);
  }

  createObjectTC(typeDef) {
    return this.TypeComposer.create(typeDef);
  }

  createInputTC(typeDef) {
    return this.InputTypeComposer.create(typeDef);
  }

  createEnumTC(typeDef) {
    return this.EnumTypeComposer.create(typeDef);
  }

  createInterfaceTC(typeDef) {
    return this.InterfaceTypeComposer.create(typeDef);
  }

  createUnionTC(typeDef) {
    return this.UnionTypeComposer.create(typeDef);
  }

  createScalarTC(typeDef) {
    return this.ScalarTypeComposer.create(typeDef);
  }

  addDirective(directive) {
    if (!(directive instanceof _graphql.GraphQLDirective)) {
      throw new Error(`You should provide GraphQLDirective to schemaComposer.addDirective(), but recieved ${(0, _misc.inspect)(directive)}`);
    }

    if (!this.hasDirective(directive)) {
      this._directives.push(directive);
    }

    return this;
  }

  removeDirective(directive) {
    this._directives = this._directives.filter(o => o !== directive);
    return this;
  }

  getDirectives() {
    return this._directives;
  }

  hasDirective(directive) {
    if (!directive) return false;

    if (typeof directive === 'string') {
      const name = directive.startsWith('@') ? directive.slice(1) : directive;
      return !!this._directives.find(o => o.name === name);
    } else if (directive instanceof _graphql.GraphQLDirective) {
      return !!this._directives.find(o => o === directive);
    }

    return false;
  }

}

exports.SchemaComposer = SchemaComposer;